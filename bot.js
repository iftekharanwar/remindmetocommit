require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const { generateProjectIdea, getUserGitHubProfile } = require('./ai-service');
const { getChatResponse, clearHistory } = require('./chat-service');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_USERNAME = process.env.GITHUB_USERNAME;

const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

const statsFile = path.join(__dirname, 'stats.json');

function loadStats() {
    if (fs.existsSync(statsFile)) {
        return JSON.parse(fs.readFileSync(statsFile, 'utf8'));
    }
    return {
        totalDaysTracked: 0,
        currentStreak: 0,
        longestStreak: 0,
        lastCommitDate: null,
        totalCommits: 0,
        suggestionsRequested: 0
    };
}

function saveStats(stats) {
    fs.writeFileSync(statsFile, JSON.stringify(stats, null, 2));
}

async function getGitHubStreak() {
    try {
        const response = await axios.get(
            `https://api.github.com/users/${GITHUB_USERNAME}/events/public?per_page=100`,
            {
                headers: { 'Authorization': `token ${GITHUB_TOKEN}` }
            }
        );

        const commitDates = new Set();
        response.data.forEach(event => {
            if (event.type === 'PushEvent') {
                const date = event.created_at.split('T')[0];
                commitDates.add(date);
            }
        });

        const sortedDates = Array.from(commitDates).sort().reverse();
        let currentStreak = 0;
        const today = new Date().toISOString().split('T')[0];

        for (let i = 0; i < sortedDates.length; i++) {
            const expectedDate = new Date();
            expectedDate.setDate(expectedDate.getDate() - i);
            const expected = expectedDate.toISOString().split('T')[0];

            if (sortedDates[i] === expected || (i === 0 && sortedDates[i] === today)) {
                currentStreak++;
            } else {
                break;
            }
        }

        return currentStreak;
    } catch (error) {
        console.error('Error calculating streak:', error.message);
        return 0;
    }
}

// Command: /start
bot.onText(/\/start/, (msg) => {
    const chatId = msg.chat.id;
    const welcomeMessage = `üëã Welcome to *GitHub Commit Reminder Bot*!\n\n` +
        `I'll help you maintain your GitHub streak by:\n` +
        `‚úÖ Checking if you've committed today\n` +
        `ü§ñ Suggesting AI-generated project ideas\n` +
        `üìä Tracking your commit statistics\n\n` +
        `*Available Commands:*\n` +
        `/suggest - Get a new project idea\n` +
        `/stats - View your GitHub stats\n` +
        `/help - Show this help message\n\n` +
        `You'll automatically receive reminders at 8 PM IST if you haven't committed!`;

    bot.sendMessage(chatId, welcomeMessage, { parse_mode: 'Markdown' });
});

// Command: /help
bot.onText(/\/help/, (msg) => {
    const chatId = msg.chat.id;
    const helpMessage = `*GitHub Commit Reminder Bot - Help*\n\n` +
        `*Commands:*\n` +
        `/start - Get started and see welcome message\n` +
        `/suggest - Get an AI-generated project idea\n` +
        `/stats - View your GitHub statistics and streak\n` +
        `/help - Show this help message\n\n` +
        `*How it works:*\n` +
        `‚Ä¢ Every day at 8 PM IST, I check if you've committed\n` +
        `‚Ä¢ If not, I send you a unique project idea generated by AI\n` +
        `‚Ä¢ Ideas are tailored to your GitHub profile and skills\n` +
        `‚Ä¢ You can request ideas anytime with /suggest\n\n` +
        `Keep coding! üí™`;

    bot.sendMessage(chatId, helpMessage, { parse_mode: 'Markdown' });
});

// Command: /suggest
bot.onText(/\/suggest/, async (msg) => {
    const chatId = msg.chat.id;

    bot.sendMessage(chatId, 'ü§ñ Generating a unique project idea for you...');

    try {
        const project = await generateProjectIdea(GITHUB_USERNAME, GITHUB_TOKEN);

        const stats = loadStats();
        stats.suggestionsRequested++;
        saveStats(stats);

        const message = `üí° *AI-Generated Project Idea*\n\n` +
            `*${project.title}*\n\n` +
            `${project.description}\n\n` +
            `*Tech Stack:* ${project.techStack}\n` +
            `*Difficulty:* ${project.difficulty}\n\n` +
            `Ready to build? Let's code! üöÄ`;

        bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
    } catch (error) {
        bot.sendMessage(chatId, '‚ùå Oops! Failed to generate idea. Try again with /suggest');
    }
});

// Command: /stats
bot.onText(/\/stats/, async (msg) => {
    const chatId = msg.chat.id;

    bot.sendMessage(chatId, 'üìä Fetching your GitHub statistics...');

    try {
        const [streak, profile] = await Promise.all([
            getGitHubStreak(),
            getUserGitHubProfile(GITHUB_USERNAME, GITHUB_TOKEN)
        ]);

        const stats = loadStats();

        const message = `üìä *Your GitHub Statistics*\n\n` +
            `üî• *Current Streak:* ${streak} day${streak !== 1 ? 's' : ''}\n` +
            `üì¶ *Public Repos:* ${profile.publicRepos}\n` +
            `üíª *Languages:* ${profile.languages || 'N/A'}\n` +
            `ü§ñ *AI Suggestions Requested:* ${stats.suggestionsRequested}\n\n` +
            `*Recent Projects:*\n${profile.recentRepos}\n\n` +
            `Keep building! üí™`;

        bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
    } catch (error) {
        bot.sendMessage(chatId, '‚ùå Failed to fetch stats. Please try again.');
    }
});

// Command: /clear - Clear conversation history
bot.onText(/\/clear/, (msg) => {
    const chatId = msg.chat.id;
    clearHistory(chatId);
    bot.sendMessage(chatId, 'üóëÔ∏è Conversation history cleared! Starting fresh.');
});

function splitMessage(text, maxLength = 4000) {
    if (text.length <= maxLength) {
        return [text];
    }

    const parts = [];
    let current = '';

    const paragraphs = text.split('\n\n');

    for (const paragraph of paragraphs) {
        if ((current + paragraph).length > maxLength) {
            if (current) parts.push(current.trim());
            current = paragraph + '\n\n';
        } else {
            current += paragraph + '\n\n';
        }
    }

    if (current) parts.push(current.trim());
    return parts;
}

function escapeMarkdown(text) {
    return text.replace(/([_*\[\]()~`>#+\-=|{}.!\\])/g, '\\$1');
}

bot.on('message', async (msg) => {
    const chatId = msg.chat.id;
    const text = msg.text;

    if (text && text.startsWith('/')) {
        return;
    }

    if (!text) {
        return;
    }

    try {
        bot.sendChatAction(chatId, 'typing');

        const profile = await getUserGitHubProfile(GITHUB_USERNAME, GITHUB_TOKEN);

        const response = await getChatResponse(chatId, text, profile);

        const messageParts = splitMessage(response);

        for (let i = 0; i < messageParts.length; i++) {
            const part = messageParts[i];

            try {
                await bot.sendMessage(chatId, part, { parse_mode: 'Markdown' });
            } catch (markdownError) {
                console.log('Markdown parsing failed, sending as plain text');
                await bot.sendMessage(chatId, part);
            }

            if (i < messageParts.length - 1) {
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }
    } catch (error) {
        console.error('Error handling message:', error);
        bot.sendMessage(chatId, '‚ùå Sorry, I encountered an error. Please try again!');
    }
});

console.log('ü§ñ Bot is running! Send commands or chat naturally...');
console.log('Commands: /start, /help, /suggest, /stats, /clear');
console.log('üí¨ You can also just chat with me about anything coding-related!');
console.log('Press Ctrl+C to stop.');
