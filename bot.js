require('dotenv').config();
const TelegramBot = require('node-telegram-bot-api');
const { generateProjectIdea, getUserGitHubProfile } = require('./ai-service');
const axios = require('axios');
const fs = require('fs');
const path = require('path');

const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const GITHUB_TOKEN = process.env.GITHUB_TOKEN;
const GITHUB_USERNAME = process.env.GITHUB_USERNAME;

const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

const statsFile = path.join(__dirname, 'stats.json');

function loadStats() {
    if (fs.existsSync(statsFile)) {
        return JSON.parse(fs.readFileSync(statsFile, 'utf8'));
    }
    return {
        totalDaysTracked: 0,
        currentStreak: 0,
        longestStreak: 0,
        lastCommitDate: null,
        totalCommits: 0,
        suggestionsRequested: 0
    };
}

function saveStats(stats) {
    fs.writeFileSync(statsFile, JSON.stringify(stats, null, 2));
}

async function getGitHubStreak() {
    try {
        const response = await axios.get(
            `https://api.github.com/users/${GITHUB_USERNAME}/events/public?per_page=100`,
            {
                headers: { 'Authorization': `token ${GITHUB_TOKEN}` }
            }
        );

        const commitDates = new Set();
        response.data.forEach(event => {
            if (event.type === 'PushEvent') {
                const date = event.created_at.split('T')[0];
                commitDates.add(date);
            }
        });

        const sortedDates = Array.from(commitDates).sort().reverse();
        let currentStreak = 0;
        const today = new Date().toISOString().split('T')[0];

        for (let i = 0; i < sortedDates.length; i++) {
            const expectedDate = new Date();
            expectedDate.setDate(expectedDate.getDate() - i);
            const expected = expectedDate.toISOString().split('T')[0];

            if (sortedDates[i] === expected || (i === 0 && sortedDates[i] === today)) {
                currentStreak++;
            } else {
                break;
            }
        }

        return currentStreak;
    } catch (error) {
        console.error('Error calculating streak:', error.message);
        return 0;
    }
}

// Command: /start
bot.onText(/\/start/, (msg) => {
    const chatId = msg.chat.id;
    const welcomeMessage = `ğŸ‘‹ Welcome to *GitHub Commit Reminder Bot*!\n\n` +
        `I'll help you maintain your GitHub streak by:\n` +
        `âœ… Checking if you've committed today\n` +
        `ğŸ¤– Suggesting AI-generated project ideas\n` +
        `ğŸ“Š Tracking your commit statistics\n\n` +
        `*Available Commands:*\n` +
        `/suggest - Get a new project idea\n` +
        `/stats - View your GitHub stats\n` +
        `/help - Show this help message\n\n` +
        `You'll automatically receive reminders at 8 PM IST if you haven't committed!`;

    bot.sendMessage(chatId, welcomeMessage, { parse_mode: 'Markdown' });
});

// Command: /help
bot.onText(/\/help/, (msg) => {
    const chatId = msg.chat.id;
    const helpMessage = `*GitHub Commit Reminder Bot - Help*\n\n` +
        `*Commands:*\n` +
        `/start - Get started and see welcome message\n` +
        `/suggest - Get an AI-generated project idea\n` +
        `/stats - View your GitHub statistics and streak\n` +
        `/help - Show this help message\n\n` +
        `*How it works:*\n` +
        `â€¢ Every day at 8 PM IST, I check if you've committed\n` +
        `â€¢ If not, I send you a unique project idea generated by AI\n` +
        `â€¢ Ideas are tailored to your GitHub profile and skills\n` +
        `â€¢ You can request ideas anytime with /suggest\n\n` +
        `Keep coding! ğŸ’ª`;

    bot.sendMessage(chatId, helpMessage, { parse_mode: 'Markdown' });
});

// Command: /suggest
bot.onText(/\/suggest/, async (msg) => {
    const chatId = msg.chat.id;

    bot.sendMessage(chatId, 'ğŸ¤– Generating a unique project idea for you...');

    try {
        const project = await generateProjectIdea(GITHUB_USERNAME, GITHUB_TOKEN);

        const stats = loadStats();
        stats.suggestionsRequested++;
        saveStats(stats);

        const message = `ğŸ’¡ *AI-Generated Project Idea*\n\n` +
            `*${project.title}*\n\n` +
            `${project.description}\n\n` +
            `*Tech Stack:* ${project.techStack}\n` +
            `*Difficulty:* ${project.difficulty}\n\n` +
            `Ready to build? Let's code! ğŸš€`;

        bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
    } catch (error) {
        bot.sendMessage(chatId, 'âŒ Oops! Failed to generate idea. Try again with /suggest');
    }
});

// Command: /stats
bot.onText(/\/stats/, async (msg) => {
    const chatId = msg.chat.id;

    bot.sendMessage(chatId, 'ğŸ“Š Fetching your GitHub statistics...');

    try {
        const [streak, profile] = await Promise.all([
            getGitHubStreak(),
            getUserGitHubProfile(GITHUB_USERNAME, GITHUB_TOKEN)
        ]);

        const stats = loadStats();

        const message = `ğŸ“Š *Your GitHub Statistics*\n\n` +
            `ğŸ”¥ *Current Streak:* ${streak} day${streak !== 1 ? 's' : ''}\n` +
            `ğŸ“¦ *Public Repos:* ${profile.publicRepos}\n` +
            `ğŸ’» *Languages:* ${profile.languages || 'N/A'}\n` +
            `ğŸ¤– *AI Suggestions Requested:* ${stats.suggestionsRequested}\n\n` +
            `*Recent Projects:*\n${profile.recentRepos}\n\n` +
            `Keep building! ğŸ’ª`;

        bot.sendMessage(chatId, message, { parse_mode: 'Markdown' });
    } catch (error) {
        bot.sendMessage(chatId, 'âŒ Failed to fetch stats. Please try again.');
    }
});

console.log('ğŸ¤– Bot is running! Send commands on Telegram...');
console.log('Available commands: /start, /help, /suggest, /stats');
console.log('Press Ctrl+C to stop.');
